---
layout: post
tag: de
title: "Schwarzer GÃ¼rtel, Dan 5: Kubernetes Operator"
subtitle: "Automatisierung in der IT-Landschaft ist ein langverfolgtes Ziel. Mit Werkzeugen wie Puppet, Chef oder Ansible verfolgt der Operator den Ansatz, immer wiederkehrende Ablaeufe dem Computer zu ueberlassen. Oder vordefinierte Zustaende von Umgebungen im Serverpark auszurollen. Spaetestens seit DevOps ist dabei aber immer die komplette Wertschoepfungskette und damit der Lebenszyklus einer Applikation zu betrachten."
date: 2020-07-10
background: '/images/k8s-cosmos.png'
---

Das Problem von Automatisierungstools aller Art ist es, dass man zuerst die Tools lernen muss, um sie fuer die eigentliche Aufgabe nutzen zu koennen, etwa eine Applikation oder eine Datenbank zu installieren. Mit der Zeit kuemmert man sich auch um den Lebenszyklus dieser Tools. Neue Releases erscheinen, mit neuen Funktionen und neuer Syntax. Dabei wollte man doch bloss die Applikation installieren?!

Wenn man sich erst einmal auf Kubernetes eingelassen hat, wird man schnell familiaer mit der Syntax der Resource-Dateien, sei es ein <a href="https://v1-17.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#deployment-v1-apps">Deployment</a> oder ein <a href="https://v1-17.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#pod-v1-core">Pod</a>. Es wird dem Anwender mit kubectl auch leicht gemacht, in welchem Format er seine Ausgaben sehen moechte; json, yaml, plain.  Die bereitgestellten Informationen sind immer dieselben: Metadaten, Specs, Status. <strong>Wie waere es, wenn Applikationsen jetzt genauso in diesem Format bereitgestellt werden wuerden???</strong>.  Mit <a href="https://v1-17.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#customresourcedefinition-v1-apiextensions-k8s-io">Custom Resource Defintion (CRD)</a> kann man die Kubernetes-API mit seiner eigenen Applikation erweitern. Etwa in der Form: meinedatenbanken.mysql.meinefirma.com. Neben den Metadaten wie Resourcename und Namespace koennte man in Specs Datenbanktyp und Groesse angeben.Willkommen in der wunderbaren Welt von <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">Kubernetes Operator</a>.

Wenn Applikationsresourcen in Kubernetes als CRD definiert sind, sollte natuerlich auch etwas damit geschehen. Wenn eine MySQL-Datenbank definiert ist, sollte diese am besten auch reell existierbar gemacht werden. Dazu gibt es den Operator, ein Programm in einem POD, der die Logic des CRD praktisch in die Landschaft umsetzt, also eine MySQL-Datenbank mit den definierten Parametern erstellt. Operatoren gibt es in Helm, <a href="https://github.com/geerlingguy/mariadb-operator">Ansible</a> und <a href="https://github.com/abalki001/mariadb-operator">Go-Programmierung</a>.  Es gibt aber auch <a href="https://github.com/flant/shell-operator">Shell-Operatoren</a> oder einen in <a href="https://github.com/hashicorp/terraform-k8s">Terraform</a>. Fuer die automatisierte Installation und Konfiguration, dem Level 1,  sollten alle Operatoren genuegen. Jetzt gehts aber noch weiter. 

Im Level 2 soll eine Applikation, wie eine MySQL-Datennbank, upgradefaehig sein. Also ich kann eine Instanz updaten, ohne das es eine Servicebeeintraechtigung gibt. Da haette an beim Shell-Operatore schon etwas Aufwand. Gehen wir gleich zu Level 3 weiter: Hier wird schon der volle Lebenszyklus der Applikation gefordert: Speicherverwaltung, Backup, Wiederherstellung im Fehlerfall. Die meisten Operatoren streichen hier die Segel, weil es schon ein sehr hoher Aufwand ist, von 0 an sowas zu programmieren. Gute gebaute Ansible-Module bekommen sowas hin. Oder Operatoren in Go, die dann einfach fertige Programmbibliotheken wie etwa ein S3-Backend fuer Backups benutzen.

Level 4 haelt Metriken bereit fuer Monitoring und Alarming. Logfileauswertung sind ebenfalls hier zu finden. verbunden mit einer Analyse der Arbeitslast der Applikation. Hier sind normalerweise 3th part tools im Einsatz, aber es ist gefordert, dass die Applikation selber diese Faehigkeiten besitzt.

Es endet dann im Level 5 mit der Auswertung der Daten vom Level zuvor, um die Applikation skalieren zu koennen oder sie im Ausfall zu reparieren. Also die Applikation soll das selber machen. Es gibt gerade mal eine Handvoll davon auf dem<a href="https://operatorhub.io"> Marktplatz operatorhub.io</a>, aber Vorsicht: die Liste ist nicht vollstaendig dort. Auf Github ist auch eine <a href="https://github.com/operator-framework/awesome-operators">umfangreiche Sammlung</a> gelistet. Die Qualitaet kann man immer nach den Kriterien des <a href="https://sdk.operatorframework.io/operator-capability-level.png">Operator Capability Levels</a> ueberpruefen. 

<img src="/images/2020-07-10-1.png" width="900" height="450" />

Einen etwas tieferen Einstieg mit praktischer Anleitung findet man in <a href="https://github.com/eumel8/ansible-otc-operator">ansible-otc-operator</a>. <a href="https://github.com/eumel8/ansible-otc/releases">ansible-otc</a> ist ein frueheres Toolset von mir, um mit Ansible-Playbooks Resourcen in der Open Telekom Cloud zu erstellen. Der Ansatz war event-basiert und ist sicherlich heute ueberholt. Ich habe ihn dennoch dazu benutzt, um einen Kubernetes Operator dafuer zu verwenden. Wer sich mit Ansible etwas auskennt, wird sich mit dem dazugehoerigen Operator schnell hereinfinden, zumal das <a href="https://sdk.operatorframework.io/">operator-sdk</a> automatisch den Code generieren kann. Mehr dazu auch in meinem Beispiel zu ansible-otc-operator. Viel Spass bei der <a href="https://github.com/eumel8/ansible-otc-operator/blob/master/README.md">Lektuere</a> und beim Ausprobieren.

